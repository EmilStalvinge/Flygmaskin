/* avrfreaks_fleury_mpu6050_test - an application for the Pololu Baby Orangutan B
 *
 * This application uses the Pololu AVR C/C++ Library.  For help, see:
 * -User's guide: http://www.pololu.com/docs/0J20
 * -Command reference: http://www.pololu.com/docs/0J18
 *
 * Created: 10/8/2014 7:23:11 PM
 *  Author: gebruiker
 * Peter Fleury I2C library included in this program
 */

#include <pololu/orangutan.h>
#include <avr/io.h>
#include "i2cmaster.h"

#define MPU6050  0xD0     // (0x68 << 1) I2C slave address

unsigned char ret;        // return value

volatile uint16_t fifo;   // fifo = 1 when sensor values are available and 0 when processing is done
 
uint16_t raw;             // raw sensor value
uint16_t acrawx;          // x axis acceleration raw value


ISR(PCINT1_vect)          // PC0..PC6 both rising and falling edge, ignore falling edge
{
 if(PINC & (1<<DDC0))
 {
  fifo = 1;
 }
}

void MPU6050_writereg(uint8_t reg, uint8_t val)
{
 i2c_start(MPU6050+I2C_WRITE);
 i2c_write(reg);  // go to register e.g. 106 user control
 i2c_write(val);  // set value e.g. to 0100 0000 FIFO enable
 i2c_stop();      // set stop condition = release bus
}


uint16_t MPU6050_readreg(uint8_t reg)
{
 i2c_start_wait(MPU6050+I2C_WRITE);  // set device address and write mode
 i2c_write(reg);                     // ACCEL_XOUT
 i2c_rep_start(MPU6050+I2C_READ);    // set device address and read mode
 raw = i2c_readAck();                // read one intermediate byte
 raw = (raw<<8) | i2c_readNak();     // read last byte
 i2c_stop();
 
 return raw;
} 


void Init_MPU6050()
{
 i2c_init();     // init I2C interface
 delay_ms(200);  // Wait for 200 ms.

 ret = i2c_start(MPU6050+I2C_WRITE);       // set device address and write mode
 if ( ret )
 {
  /* failed to issue start condition, possibly no device found */
  i2c_stop();
  red_led(1);    // Turn on the red LED immediately to signal the read is not ok
  while(1) {;;}  // lock program here as sensor init failed
 }
 else
 {
  /* issuing start condition ok, device accessible */
  MPU6050_writereg(0x6B, 0x00); // go to register 107 set value to 0000 0000 and wake up sensor
  MPU6050_writereg(0x19, 0x08); // go to register 25 sample rate divider set value to 0000 1000 for 1000 Hz
  MPU6050_writereg(0x1C, 0x08); // go to register 28 acceleration configuration set value to 0000 1000 for 4g, normal line tension is 2,7g
  MPU6050_writereg(0x23, 0xF8); // go to register 35 FIFO enable set value to 1111 1000 for all sensors not slave
  MPU6050_writereg(0x37, 0x10); // go to register 55 interrupt configuration set value to 0001 0000 for logic level high and read clear
  MPU6050_writereg(0x38, 0x01); // go to register 56 interrupt enable set value to 0000 0001 data ready creates interrupt
  MPU6050_writereg(0x6A, 0x40); // go to register 106 user control set value to 0100 0000 FIFO enable
 }
}

int main(void)
{
 DDRC  &= ~(1 << DDC0);   // make pin PC3 an input
 PORTC |=  (1 << DDC0);   // enable pull-up on pin PC0 (PC0 will read as high unless driven low by INT from MPU6050)

 PCMSK1 |= (1 << PCINT8); // Pin Change Mask for PCINT8 = pin PC0
 PCICR |= (1 << PCIE1);   // Pin Change Interrupt enable interrupt on PCINT14..8 (PCINT 8 = PC0)

 acrawx = 0;        // initial value, without read led will not blink

 sei();             // Enable global interrupts 

 Init_MPU6050();    // Sensor init
 delay_ms(200);     // Wait for 200 ms.

 while (1)
 { 
  if (fifo == 1)
  {
   acrawx = MPU6050_readreg(0x3B);   // read raw X acceleration from fifo
   fifo = 0;        // wait for next delivery of sensor values
  }
  
  if (acrawx > 1)   // any value should make the led blink until the interrupt over rules this after 1 second
  {
    red_led(1);     // Turn on the red LED
    delay_ms(200);  // Wait for 200 ms.
   red_led(0);      // Turn off the red LED
   delay_ms(200);   // Wait for 200 ms. 
  }
  else
  {
    red_led(0);     // Turn off the red LED to signal the read is not ok
    delay_ms(200);  // Wait for 200 ms.
  }
 }
}
