#define F_CPU 8000000UL
#include <stdint.h>
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <avr/pgmspace.h>
#include <util/atomic.h>
#include "i2cmaster.h"
//#include "lcd.h"


// hardware I2C address
	#define MPU6050_ADDR  (0x68 << 1)
	
#define BAUD_RATE_9600_BPS  51  // 9600bps
#define BAUD_RATE_100000_BPS  4  // 100kbps
#define RX_BUFFER_SIZE    25

// definition of the DS1307 hardware registers - eight 8-bit registers
enum { gxh, gxl, gyh, gyl, gzh, gzl, DSREGS};
	
	

// +-----------------------------------------------------------------------+ //

uint8_t rxReadPos = 0;
uint8_t rxWritePos = 0;
char _payload[RX_BUFFER_SIZE];
uint16_t channels[5];
uint8_t Buffer_loaded = 0;
uint8_t failsafe = 0;
uint8_t Motorcount = 1;
double k = 62.5/1500;
double m = 125-(1700 * (62.5/1500));

// memory copy of the MPU6050 registers
uint8_t DS1307_regs[DSREGS];

int16_t mapp(int16_t x, int16_t in_min, int16_t in_max, int16_t out_min, int16_t out_max)
{
	return ((x - in_min) * (out_max - out_min) / (in_max - in_min)) + out_min;
}

// read the gyro registers from the MPU6050 into the memory
void MPUread(void)
{
	uint8_t i;
	// ATOMIC BLOCK?????
		// set stop condition = release bus
		/* Commence the read. */
		i2c_start_wait(MPU6050_ADDR+I2C_WRITE);   // est device address and write mode
		i2c_write(0x43);                          //
		
		/* Commence the read. */
		_delay_us(20);
		i2c_start_wait(MPU6050_ADDR+I2C_READ);
		for (i=0; i<(DSREGS-1); i++)
		{
			_delay_us(10);
			DS1307_regs[i] = i2c_read(1);
		}
		_delay_us(10);
		DS1307_regs[DSREGS-1] = i2c_read(0);
		i2c_stop();
	
}

// Set Low Pass filter for MPU6050
void DLPFwrite(void)
{
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		i2c_start_wait(MPU6050_ADDR+I2C_WRITE);
		i2c_write(0x1A);  //start address
		
		i2c_write(0b00000100);
		
		i2c_stop();
	}
}

void initI2C(void)
{
	i2c_init();
	// powe management 0x6b
	
	i2c_start_wait(MPU6050_ADDR+I2C_WRITE);
	_delay_us(20);
	i2c_write(0x6b);
	_delay_us(20);
	i2c_write(0x00);
	_delay_us(20);
	i2c_stop();
}

void initMotor(void)
{
	DDRD = 0b11110000;
	DDRB |= (1 << PB1)|(1 << PB0);
	
	
	TCCR1A |= (1 << COM1A1) | (0 << WGM10) | (1 << WGM11);
	// set non-inverting mode

	TCCR1B |= (1 << WGM12) | (1 << WGM13) | (1 << CS10);
	// set fast PWM Mode
	
	TIMSK1 = (1 << OCIE1B);
	
	 ICR1 = 8000000UL/4000; // frequency F_cpu/wanted freq = ICR1
	 OCR1A = 1000;  // set duty cycle, 1000-2000, 0-100%
	 OCR1B= 8000000UL/4000 -100;
}

void initSBUS(void)
{
	sei();

	unsigned int ubrr = BAUD_RATE_100000_BPS;

	/* Set Baudrate  */
	UBRR0H = (ubrr>>8); // Shift the 16bit value ubrr 8 times to the right and transfer the upper 8 bits to UBBR0H register.
	UBRR0L = (ubrr);    // Copy the 16 bit value ubrr to the 8 bit UBBR0L register,Upper 8 bits are truncated while lower 8 bits are copied

	
	// init reciever
	UCSR0C = 0b00101110;       /* Set frame format: 8data, 2stop bit, even parity */
	UCSR0B = (1 << RXEN0) | (1 << RXCIE0) | (1<<TXEN0) ;   /* Enable  rx, tx  , enable interrupts         */
}

/*
void initLCD(void)
{
	//init LCD
	lcd_init(LCD_DISP_ON);
	lcd_clrscr();
	lcd_gotoxy(1,0);
	lcd_puts_P("MPU6050 TEST");
	_delay_ms(1000);
	lcd_clrscr();
}
*/

int main()
{
	
	
	int gx,gy,gz;
	char buffer[20];
	int16_t roll_desired_anglespeed;
	
	initSBUS();
	initMotor();
	
	//initLCD();
	initI2C();
	
	DLPFwrite();
	
	
	
	////////////////KP////////////////////
	
	//unit8_t roll_kp =  1;
   	//uint8_t pitch_kp = 1;
	//unit8_t roll_ki =  0;
   	//uint8_t pitch_ki = 0;
	//unit8_t roll_kd =  0;
   	//uint8_t pitch_kd = 0;
	
	
	while(1)
	{
		MPUread();
		
		//gyro
		gx  = ( (DS1307_regs[gxh] << 8) | DS1307_regs[gxl] ) / 131;
		gy  = ( (DS1307_regs[gyh] << 8) | DS1307_regs[gyl] ) / 131;
		gz  = ( (DS1307_regs[gzh] << 8) | DS1307_regs[gzl] ) / 131;
		
		if (Buffer_loaded == 1)
		{
			channels[0]  = (uint16_t) ((_payload[1]    |_payload[2] <<8)                     & 0x07FF); // pitch  (högre värde uppåt)  mitten 1001
			channels[1]  = (uint16_t) ((_payload[2]>>3 |_payload[3] <<5)                     & 0x07FF); //roll  (högre värde till höger) 170-1815
			channels[2]  = (uint16_t) ((_payload[3]>>6 |_payload[4] <<2 |_payload[5]<<10)  	 & 0x07FF); // throttle (högre värde uppåt) mitt 986
			channels[3]  = (uint16_t) ((_payload[5]>>1 |_payload[6] <<7)                     & 0x07FF);  // yaw (högre värde höger) mitt 989
			channels[4]  = (uint16_t) ((_payload[6]>>4 |_payload[7] <<4)                     & 0x07FF);  // switch  (högre uppåt)
			if ( (_payload[24] & 0x10) == 0x10)
			{
				failsafe = 1;
			}
			Buffer_loaded = 0;
		}
		
		
		
	
		
		if (channels[2] > 1100)
		{
			PORTB= 0b00000001;;
		}
		else
		{
          PORTB= 0b00000000;
		}
		
		
		
		/*///////////////////////////P I D///////////////////////////////////*/
    

    //roll_desired_angelvelocity = 
    //pitch_desired_angelvelocity =  
         
    
    //roll_error = roll_angelvelocity - roll_desired_angelvelocity;
    //pitch_error = pitch_angelvelocity - pitch_desired_angelvelocity;    
    
    //roll_pid_p = roll_kp*roll_error;
    //pitch_pid_p = pitch_kp*pitch_error;
    
    //if(-3 < roll_error <3){roll_pid_i = roll_pid_i+(roll_ki*roll_error);}
    //if(-3 < pitch_error <3){pitch_pid_i = pitch_pid_i+(pitch_ki*pitch_error);}
    
    //roll_pid_d = roll_kd*((roll_error - roll_previous_error)/elapsedTime);		//elapsed time
    //pitch_pid_d = pitch_kd*((pitch_error - pitch_previous_error)/elapsedTime);
    
    //roll_PID = roll_pid_p + roll_pid_i + roll_pid_d;
    //pitch_PID = pitch_pid_p + pitch_pid_i + pitch_pid_d;
    
    //if(roll_PID < -400){roll_PID=-400;}
    //if(roll_PID > 400) {roll_PID=400; }
    //if(pitch_PID < -4000){pitch_PID=-400;}
    //if(pitch_PID > 400) {pitch_PID=400;}
    
    //pwm_R_F  = 125 + input_THROTTLE - roll_PID - pitch_PID;
    //pwm_R_B  = 125 + input_THROTTLE - roll_PID + pitch_PID;
    //pwm_L_B  = 125 + input_THROTTLE + roll_PID + pitch_PID;
    //pwm_L_F  = 125 + input_THROTTLE + roll_PID - pitch_PID;
   //////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	
		
	
		//OCR1A=channels[2] * k + m;    // ekvation för gas y = (62.5/1500) * X + (125-1700*(62.5/1500))
		

		
 /*   roll_desired_anglespeed= mapp(channels[1],200,1700,-90,90);

 lcd_clrscr();
sprintf(buffer, "GyroX %d ",gx);
lcd_gotoxy(0,0);
lcd_puts(buffer);

sprintf(buffer, "GyroY %d ",gy);
lcd_gotoxy(0,1);
lcd_puts(buffer);
		
		_delay_ms(40);
		*/
	}
}//end of main



ISR(TIMER1_COMPB_vect)
{
switch (Motorcount)
{
case 1: 
OCR1A = channels[2];
      PORTD=0b00010000;                               //byt bitar
	break;
	
case 2:
 OCR1A = channels[2];
      PORTD=0b00100000;                                 //byt bitar
   break;
   
case 3:
   //OCR1A = 400;
     PORTD=0b00000000;                                   //byt bitar
   break;
   
case 4:
  OCR1A = channels[2];
      PORTD=0b10000000;                                 //byt bitar
   break;
   
   case 5:
   OCR1A = channels[2];
   PORTD=0b01000000;                                 //byt bitar
   break;
   
   
   default:
   OCR1A=1000;
   PORTD=0x00;
   if(Motorcount==8)
   {
	   Motorcount=0;
   }  
} //end of switch
Motorcount++;
}


ISR(USART_RX_vect)
{
	
	_payload[rxWritePos] = UDR0;
	
	if (_payload[0] == 0x0F)              //leta efter header
	{
		rxWritePos++;

		if (rxWritePos >= RX_BUFFER_SIZE)
		{
			rxWritePos = 0;
			Buffer_loaded = 1;           // Flagga när buffern är lastad
		}
	}
}
